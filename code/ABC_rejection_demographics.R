args <- commandArgs(TRUE)
vsc <- as.double(args[1]) # 0 if code needs to run locally and 1 if code needs to run on VSC

vsc <- 0 # This line should only be execute while we are testing locally. It overrides the previous line.

pp <- project.paths[vsc+1]
ncluster <- nclusters[vsc+1]

# General path settings
datadir <- paste0(pp, "data/") # LNS data and Simpact configuration (input parameter values)
codedir <- paste0(pp, "code/") # scripts
figuresdir <- paste0(pp, "figures/") # figures generated by scripts
compiledoutput <- paste0(pp, "compiledoutput/") # html pages, word docs, slides.
simoutput <- paste0(pp, "simoutput/") # csv files and other post-simulation output

# Create path to specific datasets
wemastercleaned <- paste0(datadir,"lns cleaned excluded rel wide 2nd round 21.09.2015.rda")
lemastercleaned <- paste0(datadir,"lns cleaned excluded rel long 2nd round 21.09.2015.rda")
mlong <- paste0(datadir, "RF Mice imputed data male long 11.01.2016.rda")
flong <- paste0(datadir, "RF Mice imputed data female long 11.01.2016.rda")
mwide <- paste0(datadir, "RF Mice imputed data male wide 11.01.2016.rda")
fwide <- paste0(datadir, "RF Mice imputed data female wide 11.01.2016.rda")



library(EasyABC)
library(GGally)

if(vsc == 0){
  Simpact4ABC.wrapper_demographics <- function(inputvector){
    source("/Users/wimdelva/Documents/AIMS Essays/2016/AIMS.Commontrunk/code/postsimscript.R")
    source("/Users/wimdelva/Documents/AIMS Essays/2016/AIMS.Commontrunk/code/modeloutput_demographics.R")
    source("/Users/wimdelva/Documents/AIMS Essays/2016/AIMS.Commontrunk/code/simpact4ABC_demographics.R")
    summaryStats <- tryCatch(simpact4ABC_demographics(inputvector=inputvector), error = errFunction)
    return(summaryStats)
  }
} else if(vsc == 1){
  Simpact4ABC.wrapper_demographics <- function(inputvector){
    source("/user/data/gent/vsc400/vsc40070/simpact-test/code/postsimscript.R")
    source("/user/data/gent/vsc400/vsc40070/simpact-test/code/modeloutput_demographics.R")
    source("/user/data/gent/vsc400/vsc40070/simpact-test/code/simpact4ABC_demographics.R")
    summaryStats <- tryCatch(simpact4ABC_demographics(inputvector=inputvector), error = errFunction)
    return(summaryStats)
  }
}




# The target summary statistics:
# 0.01: average population growth rate
# 0.12: HIV prevalence 15 years after introducing HIV at year 10.
# 0.25: Partner Turnover Rate (PTR)
# 4.9: SD in age differences

#######

# Setting up prior distributions for input parameters
cfg.person.agegap.gender.dist.normal.sigma <- 3
cfg.formation.hazard.agegapry.numrel_gender <- -0.5
cfg.formation.hazard.agegapry.numrel_diff <- -0.5
cfg.person.eagerness.dist.gamma.a <- 0.25 #0.5 # 0.25
cfg.person.eagerness.dist.gamma.b <- 15 #10 # 15
cfg.formation.hazard.agegapry.eagerness_diff <- -1
cfg.formation.hazard.agegapry.gap_factor_gender_exp <- -0.3
cfg.formation.hazard.agegapry.gap_factor_gender_age <- 0.05 # We are rewriting it as a multiplication factor
cfg.formation.hazard.agegapry.meanage <- -0.2
cfg.dissolution.alpha_0 <- 0
cfg.dissolution.alpha_4 <- -0.05


preprior <- c(cfg.person.agegap.gender.dist.normal.sigma,
              cfg.formation.hazard.agegapry.numrel_gender,
              cfg.formation.hazard.agegapry.numrel_diff,
              cfg.person.eagerness.dist.gamma.a,
              cfg.person.eagerness.dist.gamma.b,
              cfg.formation.hazard.agegapry.eagerness_diff,
              cfg.formation.hazard.agegapry.gap_factor_gender_exp,
              cfg.formation.hazard.agegapry.gap_factor_gender_age,
              cfg.formation.hazard.agegapry.meanage,
              cfg.dissolution.alpha_0,
              cfg.dissolution.alpha_4)

simpact_prior <- list(c("unif", preprior[1] - 2, preprior[1] + 2),
                      c("unif", preprior[2] - 0.4, preprior[2] + 0.4),
                      c("unif", preprior[3] - 0.5, preprior[3] + 0.5),
                      c("unif", preprior[4] - 0.2, preprior[4] + 0.7), 
                      c("unif", preprior[5] - 14, preprior[5] + 25),
                      c("unif", preprior[6] - 1, preprior[6] + 1),
                      c("unif", preprior[7] - 0.2, preprior[7] + 0.25),
                      c("unif", preprior[8] - 0.05, preprior[8] + 0.05),
                      c("unif", preprior[9] - 0.2, preprior[9] + 0.2),
                      c("unif", preprior[10] - 2, preprior[10] + 1),
                      c("unif", preprior[11] - 0.05, preprior[11] + 0.05))

# Lastly, we specify the target summary statistic

sum_stat_obs <- targetSS <- c(exp(0.01),    # Exp.Growth.rate (growth rate is about 1%)
                              log(1),       # Log.PTR (partner turnover rate is about 1)
                              exp(0.12),    # Exp.hivprevs[16]: exp(HIV prevalence 15 years after HIV introduction) (about 12%)
                              exp(5),       # Exp.aAG (average age gap is about 5 years)
                              exp(4),       # Exp.sdAG (standard deviation is about 4 years)
                              exp(0.72),    # Exp.slope (slope is about 0.72)
                              26.5,         # median.age.men
                              23.5,         # median.age.women
                              exp(0.2),     # Exp.powerm (about 0.2)
                              exp(2.6),     # Exp.wsdad (about 2.6 within-individual standard deviation of age-differences)
                              exp(1.3),     # Exp.bsdad (about 1.3 between-individual standard deviaiton of age-differences)
                              exp(0.1))     # Exp.concurr.pointprev (about 10% point prevalence of concurrent relationships)
#outputvector <- c(Exp.Growth.rate, Log.PTR, Exp.hivprevs, Exp.aAG, Exp.sdAG, Exp.slope, median.age.men, median.age.women, Exp.powerm, Exp.wsdad, Exp.bsdad, Exp.concurr.pointprev)


# Now we try to run a sequential ABC scheme, according to the method proposed by Lenormand et al. 2013
# Maxime Lenormand, Franck Jabot and Guillaume Deffuant. Adaptive approximate Bayesian computation for complex models. Comput Stat (2013) 28:2777â€“2796 DOI 10.1007/s00180-013-0428-3


# Initial number of simulations
n_init <- 1000 #200 #100
alpha <- 0.5 # This is the proportion of particles kept at each step
pacc <- 0.80 #0.2 #0.2 # This is the stopping criterion of the algorithm: a small number ensures a better convergence of the algorithm, but at a cost in computing time. Must be 0 < p_acc_min < 1. The smaller, the more strict the criterion.
dist_weights <- 1.0 #c(1, 1) #c(10.0, 0.1)

# Note: If the argument summary_stat_target is not provided, ABC_rejection only launches the simulations and outputs the simulation results.
ABC_rejection_result <- ABC_rejection(model=Simpact4ABC.wrapper_demographics,
                                                              prior=simpact_prior,
                                                              nb_simul=n_init,
                                                              verbose=TRUE,
                                                              use_seed=TRUE,
                                                              seed_count=0,
                                                              n_cluster=ncluster)

DestDir <- simoutput
save(ABC_rejection_result, file = paste0(DestDir,"ABC_rejection_object.RData"))
# 
# library(plyr)
# library(data.table)
# library(reshape2)
# library(ggplot2)
# setwd("/Users/wimdelva/Dropbox (Personal)/FWO Age Mixing/Simplest age mixing simulation/simoutputfiles/test/")
# load(paste0(DestDir,"/Local_ABC_Parallel_Referencemodel_Demographics9.RData"))

# postABCplot(ABCfit = ABC_rejection_result,
#             targetSS = sum_stat_obs,
#             preprior = preprior,
#             param.prior = simpact_prior)

# Visualise distribution of features
# stats <- ABC_rejection_result$stats[, c(1,2,18:ncol(ABC_rejection_result$stats))]
# stats.df <- data.frame(rbind(sum_stat_obs, stats))
# stats.df$target <- factor(c(1, rep(0, 8)))
# 
# pairs(x = stats.df[,1:12],
#       col = stats.df$target)


ggscatmat(data = stats.df,
          columns = 1:12,
          color = "target")

# postABCplot(ABCfit = Local_ABC_Parallel_Referencemodel_Demographics10,
#             targetSS = sum_stat_obs,
#             preprior = preprior,
#             param.prior = simpact_prior)
# 
# postABCplot(ABCfit = Local_ABC_Parallel_Referencemodel_Demographics9,
#             targetSS = sum_stat_obs,
#             preprior = preprior,
#             param.prior = simpact_prior)
# 
# 
# growth.ok <- Local_ABC_Parallel_Referencemodel_Demographics9$stats[, 1] < exp(0.015) &
#   Local_ABC_Parallel_Referencemodel_Demographics9$stats[, 1] > exp(0.005)
# params.ok <- as.data.table(Local_ABC_Parallel_Referencemodel_Demographics9$param[growth.ok, ])
# pairs(params.ok)
# 
# postABCplot(ABCfit = Local_ABC_Parallel_Referencemodel_Demographics8,
#             targetSS = sum_stat_obs,
#             preprior = preprior,
#             param.prior = simpact_prior)
# postABCplot(ABCfit = Local_ABC_Parallel_Referencemodel_Demographics7,
#             targetSS = sum_stat_obs,
#             preprior = preprior,
#             param.prior = simpact_prior)
# postABCplot(ABCfit = Local_ABC_Parallel_Referencemodel_Demographics6,
#             targetSS = sum_stat_obs,
#             preprior = preprior,
#             param.prior = simpact_prior)
# names(Local_ABC_Parallel_Referencemodel_Demographics7)
